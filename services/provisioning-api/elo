<<<PROJECT_TREE>>>
.
├── app
│   ├── protocols.py
│   └── service
│       ├── gemini_flashcard_generator.py
│       └── model
│           └── flashcard.py
└── elo

3 directories, 4 files
<<<END_PROJECT_TREE>>>

<<<FILE:./app/protocols.py>>>
from typing import Protocol
from service.model.flashcard import Flashcard

class FlashcardGenerator(Protocol):
    def generate_flashcard(self, word: str, example: str | None, part: str | None) -> list[Flashcard]:
        ...<<<END_FILE:./app/protocols.py>>>

<<<FILE:./app/service/gemini_flashcard_generator.py>>>
import json
import httpx
from typing import List

from app.protocols import FlashcardGenerator
from service.model.flashcard import Flashcard, FlashcardBuilder, dto_from_dict


GEMINI_MODEL = "models/gemini-2.5-flash"
GEMINI_ENDPOINT = (
    "https://generativelanguage.googleapis.com/v1beta/"
    f"{GEMINI_MODEL}:generateContent"
)

SYSTEM_PROMPT = """
You are a lexical engine for an English vocabulary learning system.\n\nYou must return a valid JSON document only.\nNo markdown.\nNo backticks.\nNo explanations.\nNo comments.\nNo text outside JSON.\n\nThe root element must be a JSON array.\n\nInput format:\n{\n\"word\": \"<english_word>\",\n\"example\": \"<optional example sentence>\",\n\"part\": \"<optional part of speech>\"\n}\n\nOutput rules:\n1. Always return a JSON array as root.\n2. Each array element must follow this structure:\n{\n\"front\": {\n\"word\": \"<string>\",\n\"part\": \"<string>\",\n\"ipa\": \"<IPA transcription with slashes>\"\n},\n\"reverse\": {\n\"definition\": \"<dictionary-style definition>\",\n\"translation\": [\"<Polish translation>\"],\n\"example\": {\n\"sentence\": \"<example sentence>\",\n\"position\": <zero-based index of the word in the sentence>\n},\n\"synonyms\": [\"<syn1>\", \"<syn2>\", \"<syn3>\", \"<syn4>\"]\n}\n}\n3. IPA must be standard British IPA wrapped in slashes.\n4. Definition must be concise and dictionary-style.\n5. Provide 2–4 real English synonyms.\n6. Translation must be Polish.\n7. Position must be zero-based index of the exact word occurrence in the sentence.\n8. If no example is provided, generate a natural sentence.\n9. If part of speech is provided, use it. If not, determine the most common part of speech.\n10. If the word has clearly distinct meanings (different parts of speech or unrelated senses), return multiple objects in the array.\n11. Do not invent rare or obscure meanings.\n12. Do not output duplicate flashcards.
""".strip()


class GeminiFlashcardGenerator(FlashcardGenerator):

    def __init__(self, google_ai_studio_api_key: str):
        self.api_key = google_ai_studio_api_key
        self.client = httpx.Client(timeout=30.0)

    def generate_flashcard(
        self,
        word: str,
        example: str | None = None,
        part: str | None = None,
    ) -> List[Flashcard]:

        user_payload = {
            "word": word,
        }

        if example:
            user_payload["example"] = example

        if part:
            user_payload["part"] = part

        body = {
            "system_instruction": {
                "parts": [{"text": SYSTEM_PROMPT}]
            },
            "contents": [{
                "role": "user",
                "parts": [{
                    "text": json.dumps(user_payload)
                }]
            }],
            "generationConfig": {
                "temperature": 0.2,
                "response_mime_type": "application/json",
                "maxOutputTokens": 2048,
            }
        }

        response = self.client.post(
            GEMINI_ENDPOINT,
            params={"key": self.api_key},
            json=body,
        )

        response.raise_for_status()

        data = response.json()

        try:
            raw_json = data["candidates"][0]["content"]["parts"][0]["text"]
        except (KeyError, IndexError):
            raise RuntimeError("Invalid Gemini response structure")

        try:
            flashcards_data = json.loads(raw_json)
        except json.JSONDecodeError as e:
            raise RuntimeError("Gemini returned invalid JSON") from e

        return self._to_entities(flashcards_data)

    # -------------------------
    # internal mapping layer
    # -------------------------

    def _to_entities(self, flashcards_data: list[dict]) -> List[Flashcard]:
        entities: List[Flashcard] = []

        for item in flashcards_data:
            dto = dto_from_dict(item)
            builder = FlashcardBuilder.from_llm(dto)
            entity = builder.build()
            entities.append(entity)

        return entities

    def close(self):
        self.client.close()
<<<END_FILE:./app/service/gemini_flashcard_generator.py>>>

<<<FILE:./app/service/model/flashcard.py>>>
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Any
import re


# ---------------------------
# Helpers
# ---------------------------

IPA_PATTERN = re.compile(r"^/.+/$")


# ---------------------------
# Core domain model
# ---------------------------

@dataclass(frozen=True)
class Front:
    word: str
    part: str
    ipa: str

    def __post_init__(self):
        if not self.word:
            raise ValueError("word cannot be empty")

        if not self.part:
            raise ValueError("part cannot be empty")

        if not IPA_PATTERN.match(self.ipa):
            raise ValueError("IPA must be wrapped in slashes, e.g. /ˈwɜːd/")


@dataclass(frozen=True)
class Example:
    sentence: str
    position: int

    def __post_init__(self):
        if self.position < 0:
            raise ValueError("position must be zero-based and non-negative")


@dataclass(frozen=True)
class Reverse:
    definition: str
    translation: List[str]
    example: Example
    synonyms: List[str]

    def __post_init__(self):
        if not self.definition:
            raise ValueError("definition cannot be empty")

        if not self.translation:
            raise ValueError("translation must contain at least one element")

        if not (2 <= len(self.synonyms) <= 4):
            raise ValueError("synonyms must contain 2–4 elements")


@dataclass(frozen=True)
class Flashcard:
    front: Front
    reverse: Reverse

    # -------- factory from dict --------
    @staticmethod
    def from_dict(data: dict[str, Any]) -> Flashcard:
        front = Front(**data["front"])

        example = Example(**data["reverse"]["example"])

        reverse = Reverse(
            definition=data["reverse"]["definition"],
            translation=data["reverse"]["translation"],
            example=example,
            synonyms=data["reverse"]["synonyms"],
        )

        return Flashcard(front=front, reverse=reverse)

    # -------- serialization --------
    def to_dict(self) -> dict[str, Any]:
        return {
            "front": {
                "word": self.front.word,
                "part": self.front.part,
                "ipa": self.front.ipa,
            },
            "reverse": {
                "definition": self.reverse.definition,
                "translation": self.reverse.translation,
                "example": {
                    "sentence": self.reverse.example.sentence,
                    "position": self.reverse.example.position,
                },
                "synonyms": self.reverse.synonyms,
            },
        }

class FlashcardBuilder:
    def __init__(self, word: str):
        self.word = word
        self.part = None
        self.ipa = None
        self.definition = None
        self.translation = []
        self.example_sentence = None
        self.example_position = None
        self.synonyms = []

    def set_part(self, part: str):
        self.part = part

    def set_ipa(self, ipa: str):
        self.ipa = ipa

    def set_definition(self, definition: str):
        self.definition = definition

    def add_translation(self, translation: str):
        self.translation.append(translation)

    def set_example(self, sentence: str, position: int):
        self.example_sentence = sentence
        self.example_position = position

    def set_synonyms(self, synonyms: list[str]):
        self.synonyms = synonyms

    def build(self) -> Flashcard:
        return Flashcard(
            front=Front(
                word=self.word,
                part=self.part,
                ipa=self.ipa,
            ),
            reverse=Reverse(
                definition=self.definition,
                translation=self.translation,
                example=Example(
                    sentence=self.example_sentence,
                    position=self.example_position,
                ),
                synonyms=self.synonyms,
            )
        )


# TEMP HERE 

import json

def parse_gemini_response(response: dict) -> list[Flashcard]:
    raw_json = response["candidates"][0]["content"]["parts"][0]["text"]
    data = json.loads(raw_json)

    return [Flashcard.from_dict(item) for item in data]
<<<END_FILE:./app/service/model/flashcard.py>>>

<<<FILE:./elo>>>
<<<PROJECT_TREE>>>
.
├── app
│   ├── protocols.py
│   └── service
│       ├── gemini_flashcard_generator.py
│       └── model
│           └── flashcard.py
└── elo

3 directories, 4 files
<<<END_PROJECT_TREE>>>

<<<FILE:./app/protocols.py>>>
from typing import Protocol
from service.model.flashcard import Flashcard

class FlashcardGenerator(Protocol):
    def generate_flashcard(self, word: str, example: str | None, part: str | None) -> list[Flashcard]:
        ...<<<END_FILE:./app/protocols.py>>>

<<<FILE:./app/service/gemini_flashcard_generator.py>>>
import json
import httpx
from typing import List

from app.protocols import FlashcardGenerator
from service.model.flashcard import Flashcard, FlashcardBuilder, dto_from_dict


GEMINI_MODEL = "models/gemini-2.5-flash"
GEMINI_ENDPOINT = (
    "https://generativelanguage.googleapis.com/v1beta/"
    f"{GEMINI_MODEL}:generateContent"
)

SYSTEM_PROMPT = """
You are a lexical engine for an English vocabulary learning system.\n\nYou must return a valid JSON document only.\nNo markdown.\nNo backticks.\nNo explanations.\nNo comments.\nNo text outside JSON.\n\nThe root element must be a JSON array.\n\nInput format:\n{\n\"word\": \"<english_word>\",\n\"example\": \"<optional example sentence>\",\n\"part\": \"<optional part of speech>\"\n}\n\nOutput rules:\n1. Always return a JSON array as root.\n2. Each array element must follow this structure:\n{\n\"front\": {\n\"word\": \"<string>\",\n\"part\": \"<string>\",\n\"ipa\": \"<IPA transcription with slashes>\"\n},\n\"reverse\": {\n\"definition\": \"<dictionary-style definition>\",\n\"translation\": [\"<Polish translation>\"],\n\"example\": {\n\"sentence\": \"<example sentence>\",\n\"position\": <zero-based index of the word in the sentence>\n},\n\"synonyms\": [\"<syn1>\", \"<syn2>\", \"<syn3>\", \"<syn4>\"]\n}\n}\n3. IPA must be standard British IPA wrapped in slashes.\n4. Definition must be concise and dictionary-style.\n5. Provide 2–4 real English synonyms.\n6. Translation must be Polish.\n7. Position must be zero-based index of the exact word occurrence in the sentence.\n8. If no example is provided, generate a natural sentence.\n9. If part of speech is provided, use it. If not, determine the most common part of speech.\n10. If the word has clearly distinct meanings (different parts of speech or unrelated senses), return multiple objects in the array.\n11. Do not invent rare or obscure meanings.\n12. Do not output duplicate flashcards.
""".strip()


class GeminiFlashcardGenerator(FlashcardGenerator):

    def __init__(self, google_ai_studio_api_key: str):
        self.api_key = google_ai_studio_api_key
        self.client = httpx.Client(timeout=30.0)

    def generate_flashcard(
        self,
        word: str,
        example: str | None = None,
        part: str | None = None,
    ) -> List[Flashcard]:

        user_payload = {
            "word": word,
        }

        if example:
            user_payload["example"] = example

        if part:
            user_payload["part"] = part

        body = {
            "system_instruction": {
                "parts": [{"text": SYSTEM_PROMPT}]
            },
            "contents": [{
                "role": "user",
                "parts": [{
                    "text": json.dumps(user_payload)
                }]
            }],
            "generationConfig": {
                "temperature": 0.2,
                "response_mime_type": "application/json",
                "maxOutputTokens": 2048,
            }
        }

        response = self.client.post(
            GEMINI_ENDPOINT,
            params={"key": self.api_key},
            json=body,
        )

        response.raise_for_status()

        data = response.json()

        try:
            raw_json = data["candidates"][0]["content"]["parts"][0]["text"]
        except (KeyError, IndexError):
            raise RuntimeError("Invalid Gemini response structure")

        try:
            flashcards_data = json.loads(raw_json)
        except json.JSONDecodeError as e:
            raise RuntimeError("Gemini returned invalid JSON") from e

        return self._to_entities(flashcards_data)

    # -------------------------
    # internal mapping layer
    # -------------------------

    def _to_entities(self, flashcards_data: list[dict]) -> List[Flashcard]:
        entities: List[Flashcard] = []

        for item in flashcards_data:
            dto = dto_from_dict(item)
            builder = FlashcardBuilder.from_llm(dto)
            entity = builder.build()
            entities.append(entity)

        return entities

    def close(self):
        self.client.close()
<<<END_FILE:./app/service/gemini_flashcard_generator.py>>>

<<<FILE:./app/service/model/flashcard.py>>>
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Any
import re


# ---------------------------
# Helpers
# ---------------------------

IPA_PATTERN = re.compile(r"^/.+/$")


# ---------------------------
# Core domain model
# ---------------------------

@dataclass(frozen=True)
class Front:
    word: str
    part: str
    ipa: str

    def __post_init__(self):
        if not self.word:
            raise ValueError("word cannot be empty")

        if not self.part:
            raise ValueError("part cannot be empty")

        if not IPA_PATTERN.match(self.ipa):
            raise ValueError("IPA must be wrapped in slashes, e.g. /ˈwɜːd/")


@dataclass(frozen=True)
class Example:
    sentence: str
    position: int

    def __post_init__(self):
        if self.position < 0:
            raise ValueError("position must be zero-based and non-negative")


@dataclass(frozen=True)
class Reverse:
    definition: str
    translation: List[str]
    example: Example
    synonyms: List[str]

    def __post_init__(self):
        if not self.definition:
            raise ValueError("definition cannot be empty")

        if not self.translation:
            raise ValueError("translation must contain at least one element")

        if not (2 <= len(self.synonyms) <= 4):
            raise ValueError("synonyms must contain 2–4 elements")


@dataclass(frozen=True)
class Flashcard:
    front: Front
    reverse: Reverse

    # -------- factory from dict --------
    @staticmethod
    def from_dict(data: dict[str, Any]) -> Flashcard:
        front = Front(**data["front"])

        example = Example(**data["reverse"]["example"])

        reverse = Reverse(
            definition=data["reverse"]["definition"],
            translation=data["reverse"]["translation"],
            example=example,
            synonyms=data["reverse"]["synonyms"],
        )

        return Flashcard(front=front, reverse=reverse)

    # -------- serialization --------
    def to_dict(self) -> dict[str, Any]:
        return {
            "front": {
                "word": self.front.word,
                "part": self.front.part,
                "ipa": self.front.ipa,
            },
            "reverse": {
                "definition": self.reverse.definition,
                "translation": self.reverse.translation,
                "example": {
                    "sentence": self.reverse.example.sentence,
                    "position": self.reverse.example.position,
                },
                "synonyms": self.reverse.synonyms,
            },
        }

class FlashcardBuilder:
    def __init__(self, word: str):
        self.word = word
        self.part = None
        self.ipa = None
        self.definition = None
        self.translation = []
        self.example_sentence = None
        self.example_position = None
        self.synonyms = []

    def set_part(self, part: str):
        self.part = part

    def set_ipa(self, ipa: str):
        self.ipa = ipa

    def set_definition(self, definition: str):
        self.definition = definition

    def add_translation(self, translation: str):
        self.translation.append(translation)

    def set_example(self, sentence: str, position: int):
        self.example_sentence = sentence
        self.example_position = position

    def set_synonyms(self, synonyms: list[str]):
        self.synonyms = synonyms

    def build(self) -> Flashcard:
        return Flashcard(
            front=Front(
                word=self.word,
                part=self.part,
                ipa=self.ipa,
            ),
            reverse=Reverse(
                definition=self.definition,
                translation=self.translation,
                example=Example(
                    sentence=self.example_sentence,
                    position=self.example_position,
                ),
                synonyms=self.synonyms,
            )
        )


# TEMP HERE 

import json

def parse_gemini_response(response: dict) -> list[Flashcard]:
    raw_json = response["candidates"][0]["content"]["parts"][0]["text"]
    data = json.loads(raw_json)

    return [Flashcard.from_dict(item) for item in data]
<<<END_FILE:./app/service/model/flashcard.py>>>

<<<FILE:./elo>>>
<<<PROJECT_TREE>>>
.
├── app
│   ├── protocols.py
│   └── service
│       ├── gemini_flashcard_generator.py
│       └── model
│           └── flashcard.py
└── elo

3 directories, 4 files
<<<END_PROJECT_TREE>>>

<<<FILE:./app/protocols.py>>>
<<<END_FILE:./elo>>>
